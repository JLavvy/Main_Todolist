import "./chunk-Q3SJYVDK.js";
import {
  OptionsColor,
  getRandom,
  getRangeValue,
  getStyleFromHsl,
  rangeColorToHsl,
  setRangeValue
} from "./chunk-SMEKTICL.js";
import "./chunk-ZS7NZCD4.js";

// node_modules/@tsparticles/updater-twinkle/browser/Options/Classes/TwinkleValues.js
var TwinkleValues = class {
  constructor() {
    this.enable = false;
    this.frequency = 0.05;
    this.opacity = 1;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.color !== void 0) {
      this.color = OptionsColor.create(this.color, data.color);
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.frequency !== void 0) {
      this.frequency = data.frequency;
    }
    if (data.opacity !== void 0) {
      this.opacity = setRangeValue(data.opacity);
    }
  }
};

// node_modules/@tsparticles/updater-twinkle/browser/Options/Classes/Twinkle.js
var Twinkle = class {
  constructor() {
    this.lines = new TwinkleValues();
    this.particles = new TwinkleValues();
  }
  load(data) {
    if (!data) {
      return;
    }
    this.lines.load(data.lines);
    this.particles.load(data.particles);
  }
};

// node_modules/@tsparticles/updater-twinkle/browser/TwinkleUpdater.js
var TwinkleUpdater = class {
  getColorStyles(particle, context, radius, opacity) {
    const pOptions = particle.options, twinkleOptions = pOptions.twinkle;
    if (!twinkleOptions) {
      return {};
    }
    const twinkle = twinkleOptions.particles, twinkling = twinkle.enable && getRandom() < twinkle.frequency, zIndexOptions = particle.options.zIndex, zOffset = 1, zOpacityFactor = (zOffset - particle.zIndexFactor) ** zIndexOptions.opacityRate, twinklingOpacity = twinkling ? getRangeValue(twinkle.opacity) * zOpacityFactor : opacity, twinkleRgb = rangeColorToHsl(twinkle.color), twinkleStyle = twinkleRgb ? getStyleFromHsl(twinkleRgb, twinklingOpacity) : void 0, res = {}, needsTwinkle = twinkling && twinkleStyle;
    res.fill = needsTwinkle ? twinkleStyle : void 0;
    res.stroke = needsTwinkle ? twinkleStyle : void 0;
    return res;
  }
  async init() {
    await Promise.resolve();
  }
  isEnabled(particle) {
    const pOptions = particle.options, twinkleOptions = pOptions.twinkle;
    if (!twinkleOptions) {
      return false;
    }
    return twinkleOptions.particles.enable;
  }
  loadOptions(options, ...sources) {
    if (!options.twinkle) {
      options.twinkle = new Twinkle();
    }
    for (const source of sources) {
      options.twinkle.load(source == null ? void 0 : source.twinkle);
    }
  }
  async update() {
    await Promise.resolve();
  }
};
export {
  TwinkleUpdater
};
//# sourceMappingURL=TwinkleUpdater-DTM4XAW3.js.map
