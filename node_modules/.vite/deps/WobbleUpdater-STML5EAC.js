import "./chunk-Q3SJYVDK.js";
import {
  getRandom,
  getRangeValue,
  isNumber,
  millisecondsToSeconds,
  setRangeValue
} from "./chunk-SMEKTICL.js";
import "./chunk-ZS7NZCD4.js";

// node_modules/@tsparticles/updater-wobble/browser/Options/Classes/WobbleSpeed.js
var WobbleSpeed = class {
  constructor() {
    this.angle = 50;
    this.move = 10;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.angle !== void 0) {
      this.angle = setRangeValue(data.angle);
    }
    if (data.move !== void 0) {
      this.move = setRangeValue(data.move);
    }
  }
};

// node_modules/@tsparticles/updater-wobble/browser/Options/Classes/Wobble.js
var Wobble = class {
  constructor() {
    this.distance = 5;
    this.enable = false;
    this.speed = new WobbleSpeed();
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.distance !== void 0) {
      this.distance = setRangeValue(data.distance);
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.speed !== void 0) {
      if (isNumber(data.speed)) {
        this.speed.load({ angle: data.speed });
      } else {
        const rangeSpeed = data.speed;
        if (rangeSpeed.min !== void 0) {
          this.speed.load({ angle: rangeSpeed });
        } else {
          this.speed.load(data.speed);
        }
      }
    }
  }
};

// node_modules/@tsparticles/updater-wobble/browser/Utils.js
var defaultDistance = 0;
var double = 2;
var doublePI = Math.PI * double;
var distanceFactor = 60;
function updateWobble(particle, delta) {
  const { wobble: wobbleOptions } = particle.options, { wobble } = particle;
  if (!(wobbleOptions == null ? void 0 : wobbleOptions.enable) || !wobble) {
    return;
  }
  const angleSpeed = wobble.angleSpeed * delta.factor, moveSpeed = wobble.moveSpeed * delta.factor, distance = moveSpeed * ((particle.retina.wobbleDistance ?? defaultDistance) * delta.factor) / (millisecondsToSeconds / distanceFactor), max = doublePI, { position } = particle;
  wobble.angle += angleSpeed;
  if (wobble.angle > max) {
    wobble.angle -= max;
  }
  position.x += distance * Math.cos(wobble.angle);
  position.y += distance * Math.abs(Math.sin(wobble.angle));
}

// node_modules/@tsparticles/updater-wobble/browser/WobbleUpdater.js
var double2 = 2;
var doublePI2 = Math.PI * double2;
var maxAngle = 360;
var moveSpeedFactor = 10;
var defaultDistance2 = 0;
var WobbleUpdater = class {
  constructor(container) {
    this.container = container;
  }
  init(particle) {
    const wobbleOpt = particle.options.wobble;
    if (wobbleOpt == null ? void 0 : wobbleOpt.enable) {
      particle.wobble = {
        angle: getRandom() * doublePI2,
        angleSpeed: getRangeValue(wobbleOpt.speed.angle) / maxAngle,
        moveSpeed: getRangeValue(wobbleOpt.speed.move) / moveSpeedFactor
      };
    } else {
      particle.wobble = {
        angle: 0,
        angleSpeed: 0,
        moveSpeed: 0
      };
    }
    particle.retina.wobbleDistance = getRangeValue((wobbleOpt == null ? void 0 : wobbleOpt.distance) ?? defaultDistance2) * this.container.retina.pixelRatio;
  }
  isEnabled(particle) {
    var _a;
    return !particle.destroyed && !particle.spawning && !!((_a = particle.options.wobble) == null ? void 0 : _a.enable);
  }
  loadOptions(options, ...sources) {
    if (!options.wobble) {
      options.wobble = new Wobble();
    }
    for (const source of sources) {
      options.wobble.load(source == null ? void 0 : source.wobble);
    }
  }
  update(particle, delta) {
    if (!this.isEnabled(particle)) {
      return;
    }
    updateWobble(particle, delta);
  }
};
export {
  WobbleUpdater
};
//# sourceMappingURL=WobbleUpdater-STML5EAC.js.map
